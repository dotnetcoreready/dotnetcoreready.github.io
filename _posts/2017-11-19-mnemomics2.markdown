---
layout: post
title:  "Resharper Mnemics 2!"
date:   2017-11-19 15:29:16 +0000
---

Mnemonics is a Resharper project that creates loads of additional code templates that you can access from intellisense. If you type 'c' in your C# file, an option will come up in intellisense. Pressing 'tab' will expand the template out into a new class template.

![Generating a class]({{ "/assets/1-c-intellisense.png" | absolute_url }})

On pressing tab, the following template will be generated:

![Resulting template]({{ "/assets/2-c-expanded.PNG" | absolute_url }})

Here's another example for generating a getter-only property for a string:

![Generating a string getter]({{ "/assets/3-pgs-intellisense.png" | absolute_url }})

'pg' will generate a getter only property and the 's' will make it a type of string:

![Resulting template]({{ "/assets/4-pgs-expanded.PNG" | absolute_url }})

The Mnemonics program generates over 600 of these shortcuts, allowing you to generate instance and static classes and members, including properties, methods and fields.

But the original project hasn't been updated for a few years and doesn't include some of the newer, frequently used C# constructs, such as asynchronous methods and extension methods. It also includes some templates that don't work properly - for example, the template shortcut to generate a static method that returns a list of strings is:
{% highlight c# %}
Ml.b
{% endhighlight %}
The usage of a full stop stops the intellisense from completing properly.

I've been putting together a project based on the original Mnemoics that resolves these issues and adds a range of new shortcuts.

Structure types:

| Construct         | Shortcut | 
| ----------------- |---------:|
| Instance class    | c        | 
| Static class      | C        |
| Instance method   | m        |
| Static method     | M        |
| Extension method  | X        |
| Instance property | p        |
| Static property   | P        |

For methods, you can optionally add an 'a' for an async method:

| Construct              | Shortcut |
| ---------------------- |---------:|
| Async instance method  | ma       |
| Async static method    | Ma       |
| Async extension method | Xa       |

Finally can optionally specify the return type. The shortcuts for non generic types are:

| Shortcut | Type     |
| -------- |---------:|
| Char     | c        |
| Float    | f        |
| Boolean  | b        |
| Byte     | by       | 
| Double   | d        |
| Integer  | i        |
| Long     | l        |
| String   | s        |
| Task     | t        |
| DateTime | dt       |

You can also create generic types. A generic type is indicated with a capitol letter, optionally followed by a letter indicating which non-generic type to use:

| Type           | Shortcut | 
| -------------- |---------:|
| List<T>        | L        |
| Task<T>        | T        | 
| IEnumerable<T> | E        | 

So to generate an async extension method that returns an enumerable of strings you would use `XaEs` which would give you the following template:

```
public static async Task<IEnumerable<string>> MyMethod(this PTYPE val)
{
    |
}
```

By tabbing through you will be able to fill out the method name, parameter type and body in turn.

However, quite often you want to return a custom type from a function instead of one of the basic types. You can fill in your own custom return type by simply leaving off the letter / letters indicating the return type. For example, the mnemoic `mE` would create a template for an instance method that returns an `IEnumerable` of something, and tabbing through will enable you to fill in the return type followed by the body:
````
public IEnumerable<TRETURN> MyMethod()
{
    |
}
```
Likewise, here is an example for a static async method with a custom return type using the mnemoic `Ma`:
```
public static async Task<TRETURN> MyMethod()
{
    |
}
```
Another example to generate a public-get private-set property of type list of guids `pvLi` would generate the following template:

```
public List<string> MyProperty { get; private set; }
```

This project is still fairly experimental, but you can find it [here](https://github.com/mistakenot/mnemonics). Installation instructions are included.

